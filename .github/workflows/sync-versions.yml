name: Sync Versions on Release

on:
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to sync (e.g., 0.3.4)'
        required: false

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Verify required tools
      run: |
        set -e
        echo "Verifying required tools..."
        
        if ! command -v jq &> /dev/null; then
          echo "❌ jq is not installed"
          exit 1
        fi
        
        if ! command -v sed &> /dev/null; then
          echo "❌ sed is not installed"
          exit 1
        fi
        
        echo "✅ All required tools are available"
        jq --version
        sed --version | head -1
    
    - name: Extract version from release or input
      id: version
      run: |
        set -e
        
        if [ "${{ github.event_name }}" == "release" ]; then
          VERSION="${{ github.event.release.tag_name }}"
          if [ -z "$VERSION" ]; then
            echo "❌ Release tag name is empty"
            exit 1
          fi
          # Remove 'v' prefix if present
          VERSION=${VERSION#v}
        else
          VERSION="${{ github.event.inputs.version }}"
        fi
        
        if [ -z "$VERSION" ]; then
          echo "❌ No version specified"
          exit 1
        fi
        
        # Validate version format (semantic versioning: x.y.z)
        if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$'; then
          echo "⚠️  Warning: Version '$VERSION' does not follow semantic versioning (x.y.z)"
          echo "   Continuing anyway, but this may cause issues"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Target version: $VERSION"
    
    - name: Verify required files exist
      run: |
        set -e
        echo "Verifying required files exist..."
        
        if [ ! -f build.gradle ]; then
          echo "❌ build.gradle not found"
          exit 1
        fi
        
        if [ ! -f server.json ]; then
          echo "❌ server.json not found"
          exit 1
        fi
        
        # Validate JSON syntax
        if ! jq . server.json > /dev/null 2>&1; then
          echo "❌ server.json is not valid JSON"
          exit 1
        fi
        
        # Check if packages array exists and has at least one element
        PACKAGE_COUNT=$(jq '.packages | length' server.json)
        if [ "$PACKAGE_COUNT" -eq 0 ]; then
          echo "❌ server.json has no packages"
          exit 1
        fi
        
        echo "✅ All required files exist and are valid"
    
    - name: Check current versions
      id: check
      run: |
        set -e
        TARGET_VERSION="${{ steps.version.outputs.version }}"
        
        # Extract version from build.gradle with error handling
        if ! grep -q "^version = " build.gradle; then
          echo "❌ Could not find 'version = ' in build.gradle"
          exit 1
        fi
        GRADLE_VERSION=$(grep "^version = " build.gradle | sed "s/version = '\\(.*\\)'/\\1/" | tr -d "'")
        
        if [ -z "$GRADLE_VERSION" ]; then
          echo "❌ Could not extract version from build.gradle"
          exit 1
        fi
        
        # Extract version from server.json with error handling
        SERVER_VERSION=$(jq -r '.version // empty' server.json)
        if [ -z "$SERVER_VERSION" ] || [ "$SERVER_VERSION" = "null" ]; then
          echo "❌ Could not extract version from server.json"
          exit 1
        fi
        
        # Extract identifier with error handling
        SERVER_IDENTIFIER=$(jq -r '.packages[0].identifier // empty' server.json)
        if [ -z "$SERVER_IDENTIFIER" ] || [ "$SERVER_IDENTIFIER" = "null" ]; then
          echo "❌ Could not extract identifier from server.json"
          exit 1
        fi
        
        EXPECTED_IDENTIFIER="ghcr.io/${{ github.repository }}:$TARGET_VERSION"
        
        echo "Gradle version: $GRADLE_VERSION"
        echo "Server.json version: $SERVER_VERSION"
        echo "Server.json identifier: $SERVER_IDENTIFIER"
        echo "Expected identifier: $EXPECTED_IDENTIFIER"
        echo "Target version: $TARGET_VERSION"
        
        NEEDS_UPDATE=false
        UPDATES=()
        
        # Check build.gradle
        if [ "$GRADLE_VERSION" != "$TARGET_VERSION" ]; then
          echo "⚠️  build.gradle version mismatch: $GRADLE_VERSION != $TARGET_VERSION"
          NEEDS_UPDATE=true
          UPDATES+=("build.gradle")
        fi
        
        # Check server.json version
        if [ "$SERVER_VERSION" != "$TARGET_VERSION" ]; then
          echo "⚠️  server.json version mismatch: $SERVER_VERSION != $TARGET_VERSION"
          NEEDS_UPDATE=true
          UPDATES+=("server.json version")
        fi
        
        # Check server.json identifier
        if [ "$SERVER_IDENTIFIER" != "$EXPECTED_IDENTIFIER" ]; then
          echo "⚠️  server.json identifier mismatch: $SERVER_IDENTIFIER != $EXPECTED_IDENTIFIER"
          NEEDS_UPDATE=true
          UPDATES+=("server.json identifier")
        fi
        
        if [ "$NEEDS_UPDATE" = "true" ]; then
          echo "needs_update=true" >> $GITHUB_OUTPUT
          echo "updates=$(IFS=','; echo "${UPDATES[*]}")" >> $GITHUB_OUTPUT
          echo "❌ Version synchronization needed"
        else
          echo "needs_update=false" >> $GITHUB_OUTPUT
          echo "✅ All versions are synchronized"
        fi
    
    - name: Update build.gradle
      if: steps.check.outputs.needs_update == 'true'
      run: |
        set -e
        VERSION="${{ steps.version.outputs.version }}"
        
        # Create backup
        cp build.gradle build.gradle.backup
        
        # Update version in build.gradle
        if ! sed -i.bak "s/^version = '.*'/version = '$VERSION'/" build.gradle; then
          echo "❌ Failed to update build.gradle"
          mv build.gradle.backup build.gradle
          exit 1
        fi
        rm build.gradle.bak
        
        # Verify the update worked
        UPDATED_VERSION=$(grep "^version = " build.gradle | sed "s/version = '\\(.*\\)'/\\1/" | tr -d "'")
        if [ "$UPDATED_VERSION" != "$VERSION" ]; then
          echo "❌ build.gradle update failed: expected $VERSION, got $UPDATED_VERSION"
          mv build.gradle.backup build.gradle
          exit 1
        fi
        
        echo "✅ Updated build.gradle to version $VERSION"
        grep "^version = " build.gradle
        rm build.gradle.backup
    
    - name: Update server.json
      if: steps.check.outputs.needs_update == 'true'
      run: |
        set -e
        VERSION="${{ steps.version.outputs.version }}"
        REPO="${{ github.repository }}"
        
        # Create backup
        cp server.json server.json.backup
        
        # Update version and identifier in one operation to ensure atomicity
        if ! jq ".version = \"$VERSION\" | .packages[0].identifier = \"ghcr.io/$REPO:$VERSION\"" server.json > server.json.tmp; then
          echo "❌ Failed to update server.json"
          mv server.json.backup server.json
          exit 1
        fi
        
        # Validate JSON before replacing
        if ! jq . server.json.tmp > /dev/null 2>&1; then
          echo "❌ Updated server.json is not valid JSON"
          rm server.json.tmp
          mv server.json.backup server.json
          exit 1
        fi
        
        mv server.json.tmp server.json
        
        # Verify the updates worked
        UPDATED_VERSION=$(jq -r '.version' server.json)
        UPDATED_IDENTIFIER=$(jq -r '.packages[0].identifier' server.json)
        EXPECTED_IDENTIFIER="ghcr.io/$REPO:$VERSION"
        
        if [ "$UPDATED_VERSION" != "$VERSION" ]; then
          echo "❌ server.json version update failed: expected $VERSION, got $UPDATED_VERSION"
          mv server.json.backup server.json
          exit 1
        fi
        
        if [ "$UPDATED_IDENTIFIER" != "$EXPECTED_IDENTIFIER" ]; then
          echo "❌ server.json identifier update failed: expected $EXPECTED_IDENTIFIER, got $UPDATED_IDENTIFIER"
          mv server.json.backup server.json
          exit 1
        fi
        
        echo "✅ Updated server.json to version $VERSION"
        echo "Version: $UPDATED_VERSION"
        echo "Identifier: $UPDATED_IDENTIFIER"
        rm server.json.backup
    
    - name: Verify all versions are synchronized
      if: steps.check.outputs.needs_update == 'true'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        GRADLE_VERSION=$(grep "^version = " build.gradle | sed "s/version = '\\(.*\\)'/\\1/" | tr -d "'")
        SERVER_VERSION=$(jq -r '.version' server.json)
        SERVER_IDENTIFIER=$(jq -r '.packages[0].identifier' server.json)
        EXPECTED_IDENTIFIER="ghcr.io/${{ github.repository }}:$VERSION"
        
        ALL_SYNC=true
        
        if [ "$GRADLE_VERSION" != "$VERSION" ]; then
          echo "❌ build.gradle still has wrong version: $GRADLE_VERSION != $VERSION"
          ALL_SYNC=false
        fi
        
        if [ "$SERVER_VERSION" != "$VERSION" ]; then
          echo "❌ server.json still has wrong version: $SERVER_VERSION != $VERSION"
          ALL_SYNC=false
        fi
        
        if [ "$SERVER_IDENTIFIER" != "$EXPECTED_IDENTIFIER" ]; then
          echo "❌ server.json still has wrong identifier: $SERVER_IDENTIFIER != $EXPECTED_IDENTIFIER"
          ALL_SYNC=false
        fi
        
        if [ "$ALL_SYNC" = "true" ]; then
          echo "✅ All versions are now synchronized to $VERSION"
        else
          echo "❌ Version synchronization failed"
          exit 1
        fi
    
    - name: Commit and push changes
      if: steps.check.outputs.needs_update == 'true'
      run: |
        set -e
        VERSION="${{ steps.version.outputs.version }}"
        
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Fetch latest changes to avoid conflicts
        git fetch origin main || true
        
        # Check if there are uncommitted changes
        if ! git diff --quiet build.gradle server.json; then
          git add build.gradle server.json
          
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit (files may have been updated by another process)"
          else
            # Try to commit with retry logic
            MAX_RETRIES=3
            RETRY=0
            COMMIT_SUCCESS=false
            
            while [ $RETRY -lt $MAX_RETRIES ] && [ "$COMMIT_SUCCESS" = "false" ]; do
              RETRY=$((RETRY + 1))
              echo "Attempt $RETRY/$MAX_RETRIES: Committing version updates..."
              
              if git commit -m "chore: sync versions to $VERSION"; then
                COMMIT_SUCCESS=true
                echo "✅ Successfully committed version updates"
              else
                if [ $RETRY -lt $MAX_RETRIES ]; then
                  echo "⚠️  Commit failed, fetching latest changes and retrying..."
                  git fetch origin main
                  git rebase origin/main || git merge origin/main || true
                  git add build.gradle server.json
                  sleep 2
                fi
              fi
            done
            
            if [ "$COMMIT_SUCCESS" = "false" ]; then
              echo "❌ Failed to commit after $MAX_RETRIES attempts"
              exit 1
            fi
            
            # Try to push with retry logic
            MAX_PUSH_RETRIES=3
            PUSH_RETRY=0
            PUSH_SUCCESS=false
            
            while [ $PUSH_RETRY -lt $MAX_PUSH_RETRIES ] && [ "$PUSH_SUCCESS" = "false" ]; do
              PUSH_RETRY=$((PUSH_RETRY + 1))
              echo "Attempt $PUSH_RETRY/$MAX_PUSH_RETRIES: Pushing version updates..."
              
              if git push; then
                PUSH_SUCCESS=true
                echo "✅ Successfully pushed version updates"
              else
                if [ $PUSH_RETRY -lt $MAX_PUSH_RETRIES ]; then
                  echo "⚠️  Push failed, fetching latest changes and retrying..."
                  git fetch origin main
                  git rebase origin/main || git merge origin/main || true
                  sleep 2
                fi
              fi
            done
            
            if [ "$PUSH_SUCCESS" = "false" ]; then
              echo "❌ Failed to push after $MAX_PUSH_RETRIES attempts"
              echo "⚠️  Manual intervention may be required"
              exit 1
            fi
          fi
        else
          echo "No changes detected in build.gradle or server.json"
        fi
    
    - name: Update release tag and publish release
      if: github.event_name == 'release'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const releaseId = context.payload.release.id;
          const tagName = context.payload.release.tag_name;
          const repo = context.repo;
          
          // If versions were updated, we need to update the release tag
          const needsUpdate = '${{ steps.check.outputs.needs_update }}' === 'true';
          
          try {
            if (needsUpdate) {
              console.log(`Updating release tag ${tagName} to point to latest commit...`);
              
              // Get the latest commit SHA from the current branch
              const { data: currentCommit } = await github.rest.repos.getCommit({
                owner: repo.owner,
                repo: repo.repo,
                ref: 'HEAD'
              });
              
              console.log(`Current HEAD commit: ${currentCommit.sha}`);
              
              // Get existing tag
              let existingTag = null;
              try {
                const { data: refs } = await github.rest.git.listMatchingRefs({
                  owner: repo.owner,
                  repo: repo.repo,
                  ref: `tags/${tagName}`
                });
                
                if (refs.length > 0) {
                  existingTag = refs[0];
                  console.log(`Existing tag points to: ${existingTag.object.sha}`);
                  
                  // Only update if tag points to different commit
                  if (existingTag.object.sha === currentCommit.sha) {
                    console.log('✅ Tag already points to current commit, no update needed');
                  } else {
                    // Delete old tag
                    await github.rest.git.deleteRef({
                      owner: repo.owner,
                      repo: repo.repo,
                      ref: `tags/${tagName}`
                    });
                    console.log('✅ Deleted old tag');
                    
                    // Create new tag on current commit
                    await github.rest.git.createRef({
                      owner: repo.owner,
                      repo: repo.repo,
                      ref: `refs/tags/${tagName}`,
                      sha: currentCommit.sha
                    });
                    console.log(`✅ Created new tag ${tagName} at commit ${currentCommit.sha}`);
                  }
                } else {
                  // Tag doesn't exist, create it
                  await github.rest.git.createRef({
                    owner: repo.owner,
                    repo: repo.repo,
                    ref: `refs/tags/${tagName}`,
                    sha: currentCommit.sha
                  });
                  console.log(`✅ Created tag ${tagName} at commit ${currentCommit.sha}`);
                }
              } catch (tagError) {
                // Tag might not exist, try to create it
                if (tagError.status === 404) {
                  await github.rest.git.createRef({
                    owner: repo.owner,
                    repo: repo.repo,
                    ref: `refs/tags/${tagName}`,
                    sha: currentCommit.sha
                  });
                  console.log(`✅ Created tag ${tagName} at commit ${currentCommit.sha}`);
                } else {
                  throw tagError;
                }
              }
              
              // Update release to point to new commit
              await github.rest.repos.updateRelease({
                owner: repo.owner,
                repo: repo.repo,
                release_id: releaseId,
                target_commitish: currentCommit.sha
              });
              console.log(`✅ Updated release to point to commit ${currentCommit.sha}`);
            }
            
            // Publish the release if it's still in draft/prerelease state
            const release = context.payload.release;
            if (release.draft || release.prerelease) {
              await github.rest.repos.updateRelease({
                owner: repo.owner,
                repo: repo.repo,
                release_id: releaseId,
                draft: false,
                prerelease: false
              });
              console.log('✅ Published release');
            } else {
              console.log('✅ Release is already published');
            }
          } catch (error) {
            console.error('❌ Error updating release:', error.message);
            if (error.response) {
              console.error('Response status:', error.response.status);
              console.error('Response data:', JSON.stringify(error.response.data, null, 2));
            }
            throw error;
          }
    
    - name: Create summary
      run: |
        if [ "${{ steps.check.outputs.needs_update }}" = "true" ]; then
          echo "## Version Synchronization Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ All versions have been synchronized to **${{ steps.version.outputs.version }}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Updated files:" >> $GITHUB_STEP_SUMMARY
          IFS=',' read -ra UPDATES <<< "${{ steps.check.outputs.updates }}"
          for update in "${UPDATES[@]}"; do
            echo "- $update" >> $GITHUB_STEP_SUMMARY
          done
        else
          echo "## Version Synchronization Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ All versions are already synchronized to **${{ steps.version.outputs.version }}**" >> $GITHUB_STEP_SUMMARY
        fi

